import { useEffect, useMemo, useRef, useState } from 'react';

import { useAppState, useWindow } from '~/components/desktop/Window/context';
import ScrollContainer from '~/components/ui/ScrollContainer';

import DitherLabImageInfo from './panels/DitherLabImageInfo';
import DitherLabResizeOptions from './panels/DitherLabResizeOptions';
import GlRenderer from './renderers/GlRenderer';
import DitherLabRenderOptions from './panels/DitherLabRenderOptions';
import DitherLabPaletteSelect from './panels/DitherLabPaletteSelect';
import { files } from '../Files';
import Menu from '~/components/ui/Menu';
import Button from '~/components/ui/Button';
import { useAppSettings } from '~/stores/system';
import cn from 'classnames';
import DitherLabPaletteEditor from './panels/DitherLabPaletteEditor';
import { DitherLabDevice } from './types';
import SoftwareRenderer from './renderers/SoftwareRenderer';
import palettes from '~/dither/palettes';
import {
  type Palette,
  PaletteGroup,
  PaletteType,
} from '~/dither/palettes/types';
import { generatePalette } from '~/dither/paletteGen/PaletteGenerator';
import { messageBox } from '../MessageBox';
import { Toolbar } from '~/components/ui/Toolbar';

export const ZOOM_STOPS = [1, 1.5, 2, 3, 4, 6, 8, 16, 32, 64];

interface ZoomControlsProps {
  zoom: number;
  setZoom: (zoom: number) => void;
  zoomOut: () => void;
  zoomIn: () => void;
  zoomTo: (mode: 'fit' | 'fill') => void;
}

function ZoomControls({
  zoom,
  setZoom,
  zoomOut,
  zoomIn,
  zoomTo,
}: ZoomControlsProps) {
  return (
    <>
      <span className="px-2">Zoom</span>
      <div className="bg-default bevel-content p-0.5 flex flex-row">
        <Button
          className="py-0.5 px-1.5"
          onClick={zoomOut}
          disabled={zoom <= (ZOOM_STOPS.at(0) ?? 0)}
        >
          <span>-</span>
        </Button>
        <div className="py-0.5 px-2 w-12">{(zoom * 100).toFixed(0)}%</div>
        <Button
          className="py-0.5 px-1.5"
          onClick={zoomIn}
          disabled={zoom >= (ZOOM_STOPS.at(-1) ?? 0)}
        >
          <span>+</span>
        </Button>
      </div>
      <Button variant="light" className="py-1 px-2" onClick={() => setZoom(1)}>
        Reset
      </Button>
      <Button
        variant="light"
        className="py-1 px-2"
        onClick={() => zoomTo('fit')}
      >
        Fit
      </Button>
      <Button
        variant="light"
        className="py-1 px-2"
        onClick={() => zoomTo('fill')}
      >
        Fill
      </Button>
    </>
  );
}

export default function DitherLab() {
  const { close, modal } = useWindow();
  const [state, setState] = useAppState('dither');
  const [settings, set] = useAppSettings('dither');

  const hiddenInputRef = useRef<HTMLInputElement>(null);
  const importHiddenInputRef = useRef<HTMLInputElement>(null);
  const viewportRef = useRef<HTMLDivElement>(null);

  const [rt, setRt] = useState<HTMLCanvasElement | null>(null);
  const [img, setImg] = useState<HTMLImageElement | null>(null);

  const [status, setStatus] = useState<'ready' | 'rendering' | 'done'>('ready');
  const [renderTime, setRenderTime] = useState(0);

  const allPalettes = useMemo(
    () => [...palettes, ...settings.customPalettes],
    [settings.customPalettes],
  );

  useEffect(() => {
    console.log(state.paletteName);
    const palette = allPalettes.find((pal) => pal.name === state.paletteName);
    if (!palette) return;

    console.log(palette);

    // If the palette is not autogenerated, just set it as active
    if (palette.type !== PaletteType.Auto) setState({ palette });
    // For auto palettes, generate a palette from the image
    else if (img) {
      const temp = document.createElement('canvas');
      const ctx = temp.getContext('2d');
      if (!ctx) return;

      temp.width = rt?.width ?? 0;
      temp.height = rt?.height ?? 0;
      ctx.drawImage(img, 0, 0, temp.width, temp.height);
      const data = ctx.getImageData(0, 0, temp.width, temp.height);

      const generated = generatePalette(
        {
          size: palette.data[0],
          reservedLevel: palette.data[1],
          levels: palette.data[2],
          thresholdCoeff: palette.data[3],
        },
        data,
      );

      setState({ palette: generated });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allPalettes, img, rt, state.paletteName]);

  const openImage = (newImage: (typeof state)['image']) => {
    const lastImage = state.image;
    try {
      setState({ image: newImage });
    } catch (err: unknown) {
      setState({ image: lastImage });

      const message = err instanceof Error ? err.message : 'Unknown error.';
      modal(
        messageBox({
          type: 'warning',
          title: "Can't open image",
          message: `An error ocurred while opening the image: ${message} The most likely cause is insufficient localStorage memory. Try uploading a smaller image or closing other windows.`,
        }),
      );
    }
  };

  const uploadImage = (ev: React.ChangeEvent<HTMLInputElement>) => {
    const input = ev.target;
    if (input?.files) {
      const file = input.files[0];
      const reader = new FileReader();

      // if (file.size > MAX_UPLOAD_SIZE)

      reader.addEventListener(
        'load',
        () => {
          openImage({
            filename: file.name,
            url: reader.result as string,
            size: file.size,
          });
        },
        { once: true },
      );
      reader.readAsDataURL(file);
    }
  };

  const onLoad = (ev: React.SyntheticEvent<HTMLImageElement>) => {
    const { naturalWidth, naturalHeight } = ev.target as HTMLImageElement;
    setState({ naturalWidth, naturalHeight });
  };

  const upload = () => hiddenInputRef.current?.click();

  const open = () => {
    modal(
      files({
        typeFilter: ['fileImage'],
        modalCallback: (stub) =>
          openImage({
            filename: stub.name,
            size: stub.size ?? 0,
            url: `/api/safeimage?id=${stub._id}`,
          }),
      }),
    );
  };

  const download = () => {
    if (!rt || !state.image) return;
    const dataUrl = rt
      .toDataURL('image/png')
      .replace('image/png', 'image/octet-stream');

    let filename = state.image.filename.split('.').slice(0, -1).join('.');
    filename = `${filename} - ${state.palette.name}.png`;

    const link = document.createElement('a');
    link.setAttribute('download', filename);
    link.setAttribute('href', dataUrl);
    link.click();
  };

  const zoom = state.zoom;
  const setZoom = (zoom: number) => {
    setState({ zoom });
  };

  const zoomOut = () => {
    const nextZoomStop = ZOOM_STOPS.filter((stop) => stop < zoom).at(-1);
    setZoom(nextZoomStop ?? 1);
  };

  const zoomIn = () => {
    const nextZoomStop = ZOOM_STOPS.filter((stop) => stop > zoom).at(0);
    setZoom(nextZoomStop ?? 1);
  };

  const zoomTo = (mode: 'fit' | 'fill') => {
    if (!viewportRef.current || !rt) return;

    const { width: rtWidth, height: rtHeight } = rt;
    const { width, height } = viewportRef.current.getBoundingClientRect();

    // Account for image border and scrollbar
    const zoomToFitWidth = (width - 18) / rtWidth;
    const zoomToFitHeight = (height - 18) / rtHeight;

    setZoom(
      mode === 'fit'
        ? Math.min(zoomToFitWidth, zoomToFitHeight)
        : Math.max(zoomToFitWidth, zoomToFitHeight),
    );
  };

  const readPalettes = (el: HTMLImageElement) => {
    const offscreen = new OffscreenCanvas(el.naturalWidth, el.naturalHeight);
    const ctx = offscreen.getContext('2d');
    if (!ctx) return;

    ctx.drawImage(el, 0, 0);
    const data = ctx.getImageData(0, 0, offscreen.width, offscreen.height);

    const newPalettes: Palette[] = [];
    for (let i = 0; i < data.height; i++) {
      const rowIdx = i * data.width * 4;
      let j = 0;
      let name = '';
      const pdata: number[] = [];

      // Parse palette name
      while (data.data[rowIdx + j * 4 + 3] != 0) {
        name += String.fromCharCode(data.data[rowIdx + j * 4]);
        j++;
      }
      j++;

      // Parse palette data
      while (data.data[rowIdx + j * 4 + 3] != 0) {
        pdata.push(data.data[rowIdx + j * 4 + 0]);
        pdata.push(data.data[rowIdx + j * 4 + 1]);
        pdata.push(data.data[rowIdx + j * 4 + 2]);
        j++;
      }

      // Create palette
      newPalettes.push({
        name,
        type: PaletteType.Indexed,
        group: PaletteGroup.User,
        data: pdata,
      });
    }

    set({ customPalettes: [...settings.customPalettes, ...newPalettes] });
    if (newPalettes.length > 0)
      setState({ paletteGroup: PaletteGroup.User, palette: newPalettes[0] });
  };

  const importPaletteFromImage = (ev: React.ChangeEvent<HTMLInputElement>) => {
    const input = ev.target;
    if (input?.files) {
      const file = input.files[0];
      const reader = new FileReader();

      reader.addEventListener(
        'load',
        () => {
          const el = document.createElement('img');
          el.src = reader.result as string;
          el.addEventListener('load', () => {
            readPalettes(el);
            el.remove();
          });
          document.body.appendChild(el);
        },
        { once: true },
      );
      reader.readAsDataURL(file);
    }
  };

  const importPalettes = () => importHiddenInputRef.current?.click();

  const Renderer = useMemo(
    () => (state.device === DitherLabDevice.GL ? GlRenderer : SoftwareRenderer),
    [state.device],
  );

  return (
    <div className="flex flex-col gap-0.5 min-w-0 select-none">
      <input
        type="file"
        className="hidden"
        ref={hiddenInputRef}
        onChange={uploadImage}
      />
      <input
        type="file"
        className="hidden"
        ref={importHiddenInputRef}
        onChange={importPaletteFromImage}
      />
      {state.image ? (
        <img
          src={state.image.url}
          alt=""
          className="hidden"
          ref={(el) => setImg(el)}
          onLoad={onLoad}
        />
      ) : null}

      <Menu.Bar>
        <Menu.Menu trigger={<Menu.Trigger>File</Menu.Trigger>}>
          <Menu.Item label="Upload..." onSelect={upload} />
          <Menu.Item label="Open..." onSelect={open} />
          <Menu.Item label="Save" onSelect={download} />

          <Menu.Separator />

          <Menu.Item label="Exit" onSelect={close} />
        </Menu.Menu>

        <Menu.Menu trigger={<Menu.Trigger>View</Menu.Trigger>}>
          <Menu.Sub label="Zoom">
            <Menu.RadioGroup
              value={zoom.toString()}
              onValueChange={(value) => setZoom(Number(value))}
            >
              <Menu.RadioItem value="1" label="100%" />
              <Menu.RadioItem value="2" label="200%" />
              <Menu.RadioItem value="3" label="300%" />
              <Menu.RadioItem value="4" label="400%" />
              <Menu.RadioItem value="6" label="600%" />
              <Menu.RadioItem value="8" label="800%" />
            </Menu.RadioGroup>

            <Menu.Separator />

            <Menu.Item label="Zoom to fit" onSelect={() => zoomTo('fit')} />
            <Menu.Item label="Zoom to fill" onSelect={() => zoomTo('fill')} />
          </Menu.Sub>

          <Menu.Separator />

          <Menu.CheckboxItem
            label="Status Bar"
            checked={settings.showStatusBar}
            onCheckedChange={(checked) => set({ showStatusBar: checked })}
          />
          <Menu.CheckboxItem
            label="Palette Editor"
            checked={settings.showPaletteEditor}
            onCheckedChange={(checked) => set({ showPaletteEditor: checked })}
          />
          <Menu.Sub label="Tool Panels">
            <Menu.RadioGroup
              value={settings.panelSide}
              onValueChange={(value) => set({ panelSide: value as any })}
            >
              <Menu.RadioItem label="Left" value="left" />
              <Menu.RadioItem label="Right" value="right" />
            </Menu.RadioGroup>
          </Menu.Sub>
        </Menu.Menu>
      </Menu.Bar>

      <div
        className={cn('grow flex gap-0.5 min-h-0', {
          'flex-row': settings.panelSide === 'right',
          'flex-row-reverse': settings.panelSide === 'left',
        })}
      >
        <Renderer
          rt={rt}
          img={img}
          setRt={setRt}
          status={status}
          setStatus={setStatus}
          setRenderTime={setRenderTime}
          viewportRef={viewportRef}
        >
          <Toolbar className="grow">
            <Button variant="light" className="p-1" onClick={download}>
              <img src="fs/System Files/UI/save2.png" alt="Save" />
            </Button>
          </Toolbar>
          <Toolbar>
            <ZoomControls
              zoom={zoom}
              setZoom={setZoom}
              zoomOut={zoomOut}
              zoomIn={zoomIn}
              zoomTo={zoomTo}
            />
          </Toolbar>
        </Renderer>

        <div className="flex flex-row gap-0.5">
          <ScrollContainer
            hide="x"
            className="bg-surface w-[14.5rem] min-w-[14.5rem]"
          >
            <div className="flex flex-col w-[13.5rem] min-w-[13.5rem]">
              <DitherLabImageInfo upload={upload} open={open} />
              <DitherLabResizeOptions />
              <DitherLabPaletteSelect
                openEditor={() => set({ showPaletteEditor: true })}
                importPalettes={importPalettes}
              />
              <DitherLabRenderOptions />
            </div>
          </ScrollContainer>

          {settings.showPaletteEditor ? (
            <DitherLabPaletteEditor
              close={() => set({ showPaletteEditor: false })}
            />
          ) : null}
        </div>
      </div>

      {settings.showStatusBar ? (
        <div className="flex flex-row gap-0.5">
          <div className="py-0.5 px-2 bevel-light-inset text-ellipsis whitespace-nowrap overflow-hidden flex-[3]">
            {status === 'done'
              ? `Done (${renderTime.toFixed(0)}ms)`
              : status === 'ready'
              ? 'Ready'
              : 'Rendering...'}
          </div>
          <div className="py-0.5 px-2 bevel-light-inset text-ellipsis whitespace-nowrap overflow-hidden flex-1">
            {state.image?.filename}
          </div>
          <div className="py-0.5 px-2 bevel-light-inset text-ellipsis whitespace-nowrap overflow-hidden flex-1">
            {state.renderWidth}x{state.renderHeight}
          </div>
          <div className="py-0.5 px-2 bevel-light-inset text-ellipsis whitespace-nowrap overflow-hidden flex-1">
            {state.palette.name}
          </div>
        </div>
      ) : null}
    </div>
  );
}
